# ZGC收集器
---
## 介绍
```ZGC```是``JDK11``中新加入的具有实验性质的低延迟垃圾收集器，是由Oracle公司研发的。2018年Oracle创建了JEP333 将ZGC提交给OpenJDK，推动其进入OpenJDK 11的发布清单之中。

```ZGC```和```Shenandoah```的目标是高度相似的，都希望在尽可能对 ***吞吐量*** 影响不太大的前提下，实现在 ***任意堆内内存大小*** 都可以把垃圾收集器的听段时间限制在 ***10毫秒*** 以内的 ***低延迟***。但是```ZGC```和```Shenandoah```的实现思路又是差异显著的，如果说```RedHat```公司开发的```Shen-andoah```像是```Oracle```的```G1```收集器的实际继承者的话，那```Oracle```公司开发的``ZGC``就更像是``Azul System``公司独步天下的``PGC``(Pauseless GC)和``C4``(Concurrent Continuously Compacting Collector)收集器的同胞兄弟。

早在2005年，运行在``Azul VM``上的``PGC``就已经实现了标记和整理阶段全程与用户线程并发运行的垃圾收集，而运行在``Zing VM``上的``C4``收集器是``PGC``继续演进的产物，主要增加了分代收集支持，大幅提升了收集器能够承受的对象分配速度。**（这里有疑问，为什么分代收集能够提升分配速度）** 无论从算法还是实现原理上来讲，PGC和C4肯定算是一脉相承上的，而ZGC虽非Azul公司的产品，但也应视为这条脉络上的另一个节点，因为ZGC几乎所有的关键技术上，与PGC和C4都只存在技术称谓上的差别，实质内容几乎是一模一样的。相信到这里读者应该已经对Java虚拟机收集器常见的专业术语都有所了解了，如果不避讳专业术语的话，我们可以给ZGC下一个这样的定义来概括他们的主要特征：
```
ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。
```
接下来，笔者将逐项来介绍ZGC的这些技术特点。

### ZGC内存布局
首先从ZGC的内存布局说起。与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的Region（在一些官方资料中将它称为Page或者ZPage，本章为行文一致继续成为Region）具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量：
1. 小型Region（Small Region）：容量固定为2MB，用于放置小于***256KB***的小对象。
2. 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于***256KB*** 但小于 ***4MB***的对象。
3. 大型Region（Large Region）：大小不固定，可以动态变化，但必须为2MB的整数倍，用于放置***4MB***以上的大对象。

每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，以后会介绍到）的，因为复制又给大对象的代价非常高昂。
